diff --git a/statements/date_preparator.py b/statements/date_preparator.py
new file mode 100644
index 0000000..e114b35
--- /dev/null
+++ b/statements/date_preparator.py
@@ -0,0 +1,65 @@
+import calendar
+import re
+
+from abc import ABC, abstractmethod
+from datetime import datetime
+
+
+class DatePreparator(ABC):
+    @abstractmethod
+    def can_handle(self, period_begin, period_end):
+        pass
+
+    @abstractmethod
+    def prepare(self, period_begin, period_end):
+        pass
+
+class ValidateFormat(DatePreparator):
+    """ 1. if provided date contains any other signs than numbers and '-', or if it has less than 7 characters """
+    def can_handle(self, period_begin, period_end):
+        return re.search(r'[^0-9\-]', period_begin) or re.search(r'[^0-9\-]', period_end) or \
+               len(period_begin) < 7 or len(period_end) < 7
+
+    def prepare(self, period_begin, period_end):
+        raise ValueError("Invalid date format. Expected format is YYYY-MM-DD or YYYY-MM")
+
+class PrepareWholeMonthDate(DatePreparator):
+    """ 2. if someone provided the same start and end date without any day, we should show whole month report """
+    def can_handle(self, period_begin, period_end):
+        return len(period_begin) == len(period_end) == 7 and period_begin == period_end
+
+    def prepare(self, period_begin, period_end):
+        year = int(period_end[:4])
+        month = int(period_end[5:7])
+        last_day = calendar.monthrange(year, month)[1]
+        return f"{period_begin}-01", f"{period_end}-{last_day:02d}"
+
+class AddDefaultDayToMonth(DatePreparator):
+    """ 3. if someone provided different months of year in proper format YYYY-MM, we can add '-01' as day, to make it valid """
+    def can_handle(self, period_begin, period_end):
+        return len(period_begin) == len(period_end) == 7
+
+    def prepare(self, period_begin, period_end):
+        return f"{period_begin}-01", f"{period_end}-01"
+
+class ValidateDateOrder(DatePreparator):
+    """4. At this point, we assume date strings are complete (YYYY-MM-DD), check if period_end is not before period_begin"""
+    def can_handle(self, period_begin, period_end):
+        return period_begin > period_end
+
+    def prepare(self, period_begin, period_end):
+        raise ValueError("Start date (period_begin) cannot be after end date (period_end).")
+
+class FinalParser(DatePreparator):
+    """ 5. Always applies at the end, to convert the date strings to datetime.date objects """
+    def can_handle(self, period_begin, period_end):
+        return True
+
+    def prepare(self, period_begin, period_end):
+        try:
+            period_begin = datetime.strptime(period_begin, "%Y-%m-%d").date()
+            period_end = datetime.strptime(period_end, "%Y-%m-%d").date()
+        except ValueError:
+            raise ValueError("Invalid date format. Check if year/month/day exists. Expected format is YYYY-MM-DD.")
+        return period_begin, period_end
+
diff --git a/statements/migrations/0002_statement_unique_account_date_pair.py b/statements/migrations/0002_statement_unique_account_date_pair.py
new file mode 100644
index 0000000..87e336d
--- /dev/null
+++ b/statements/migrations/0002_statement_unique_account_date_pair.py
@@ -0,0 +1,17 @@
+# Generated by Django 5.2 on 2025-04-03 19:21
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('statements', '0001_initial'),
+    ]
+
+    operations = [
+        migrations.AddConstraint(
+            model_name='statement',
+            constraint=models.UniqueConstraint(fields=('account', 'date'), name='unique_account_date_pair'),
+        ),
+    ]
diff --git a/statements/migrations/0003_account_balance.py b/statements/migrations/0003_account_balance.py
new file mode 100644
index 0000000..eaa4e88
--- /dev/null
+++ b/statements/migrations/0003_account_balance.py
@@ -0,0 +1,18 @@
+# Generated by Django 5.2 on 2025-04-03 20:39
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('statements', '0002_statement_unique_account_date_pair'),
+    ]
+
+    operations = [
+        migrations.AddField(
+            model_name='account',
+            name='balance',
+            field=models.DecimalField(decimal_places=2, default=0.0, max_digits=12),
+        ),
+    ]
diff --git a/statements/migrations/0004_statementitem_account.py b/statements/migrations/0004_statementitem_account.py
new file mode 100644
index 0000000..6dcd774
--- /dev/null
+++ b/statements/migrations/0004_statementitem_account.py
@@ -0,0 +1,20 @@
+# Generated by Django 5.2 on 2025-04-04 09:02
+
+import django.db.models.deletion
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('statements', '0003_account_balance'),
+    ]
+
+    operations = [
+        migrations.AddField(
+            model_name='statementitem',
+            name='account',
+            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='statements.account'),
+            preserve_default=False,
+        ),
+    ]
diff --git a/statements/migrations/0005_account_statements__name_c3694a_idx_and_more.py b/statements/migrations/0005_account_statements__name_c3694a_idx_and_more.py
new file mode 100644
index 0000000..a553c16
--- /dev/null
+++ b/statements/migrations/0005_account_statements__name_c3694a_idx_and_more.py
@@ -0,0 +1,21 @@
+# Generated by Django 5.2 on 2025-04-04 09:10
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('statements', '0004_statementitem_account'),
+    ]
+
+    operations = [
+        migrations.AddIndex(
+            model_name='account',
+            index=models.Index(fields=['name', 'currency'], name='statements__name_c3694a_idx'),
+        ),
+        migrations.AddIndex(
+            model_name='statementitem',
+            index=models.Index(fields=['account', 'currency'], name='statements__account_0b0291_idx'),
+        ),
+    ]
diff --git a/statements/migrations/0006_statementitem_comments.py b/statements/migrations/0006_statementitem_comments.py
new file mode 100644
index 0000000..71e87bb
--- /dev/null
+++ b/statements/migrations/0006_statementitem_comments.py
@@ -0,0 +1,18 @@
+# Generated by Django 5.2 on 2025-04-04 11:24
+
+from django.db import migrations, models
+
+
+class Migration(migrations.Migration):
+
+    dependencies = [
+        ('statements', '0005_account_statements__name_c3694a_idx_and_more'),
+    ]
+
+    operations = [
+        migrations.AddField(
+            model_name='statementitem',
+            name='comments',
+            field=models.TextField(blank=True),
+        ),
+    ]
diff --git a/statements/models.py b/statements/models.py
index 91ac038..dd39d38 100644
--- a/statements/models.py
+++ b/statements/models.py
@@ -1,27 +1,111 @@
+from .date_preparator import ValidateFormat, PrepareWholeMonthDate, AddDefaultDayToMonth, ValidateDateOrder, FinalParser
 from django.db import models
+from django.db.models import Sum, Case, When, Value, F
 
+def prepare_dates(period_begin, period_end):
+    try:
+        # order of handlers is important, especially the last two. They are also proper ordered in its file with comments.
+        # if we will have new example of date format (on backend we should have it prepared in one format given from FE),
+        # but in our case we should add new handler to its file and to proper place in the list below.
+        handlers = [
+            ValidateFormat(),
+            PrepareWholeMonthDate(),
+            AddDefaultDayToMonth(),
+            ValidateDateOrder(),
+            FinalParser()
+        ]
+        for handler in handlers:
+            if handler.can_handle(period_begin, period_end):
+                period_begin, period_end = handler.prepare(period_begin, period_end)
+        return period_begin, period_end
+
+    except ValueError as e:
+        raise ValueError(e)
 
 def report_turnover_by_year_month(period_begin, period_end):
     # TODO: TASK → make report using 1 database query without any math in python
-    # example output
-    return {
-        "2009-11": {
-            {
-                "incomes": {
-                    "PLN": 120
-                },
-                "expenses": {
-                    "PLN": 100
-                }
+    # I was not sure how to behave with internal transfers, but i kept them in incomes and expenses, so overall is 0
+    # It is hard now to exclude it, I do not know if the transfer title always be the same, to take it into consideration
+    # Second thing is, that I am not pretty sure if models are good place to put this function, better is some service with reports
+    # but still do not know how test are written, so I will not refactor it.
+    try:
+        result_date_range_key = f"{period_begin}-{period_end}" if period_begin != period_end else f"{period_begin}"
+        period_begin, period_end = prepare_dates(period_begin, period_end)
+    except ValueError as e:
+        return f"Error: {e}"
+
+    transactions_amounts = StatementItem.objects.filter(
+        statement_id__in=Statement.objects.filter(date__range=[period_begin, period_end]).values_list('id', flat=True)
+    ).annotate(
+        negative_amount=Sum(
+            Case(
+                When(amount__lt=0, then=F('amount')),
+                default=Value(0),
+                output_field=models.DecimalField()
+            )
+        ),
+        positive_amount=Sum(
+            Case(
+                When(amount__gt=0, then=F('amount')),
+                default=Value(0),
+                output_field=models.DecimalField()
+            )
+        )
+    ).aggregate(
+        total_negative_amount=Sum('negative_amount'),
+        total_positive_amount=Sum('positive_amount')
+    )
+
+    if not transactions_amounts['total_positive_amount'] and transactions_amounts['total_negative_amount'] is None:
+        return f"There are no transactions in the given period: {result_date_range_key}"
+
+    result = {
+        result_date_range_key: {
+            "incomes": {
+                "PLN": float(abs(transactions_amounts['total_positive_amount']))
+            },
+            "expenses": {
+                "PLN": float(abs(transactions_amounts['total_negative_amount']))
             }
         }
     }
 
+    return result
+
+    # example output - this dict has wrong format, and will raise TypeError.
+    # dict with incomes and expenses cannot be element of set - "unhashable type: 'dict'"
+    # return {
+    #     "2009-11": {
+    #         {
+    #             "incomes": {
+    #                 "PLN": 120
+    #             },
+    #             "expenses": {
+    #                 "PLN": 100
+    #             }
+    #         }
+    #     }
+    # }
+
 
 class Account(models.Model):
     name = models.CharField(max_length=100)
     currency = models.CharField(max_length=3)
-    # TODO: TASK → add field balance that will update automatically 
+    # TODO: TASK → add field balance that will update automatically
+    # I was thinking about two approaches:
+    #   - we can use signals or extend statementItem save method, but each time balance will be updated when new item is added
+    #   - or we can do once balance update after import.
+    # I have chosen the second approach, because we are keeping eye on performance.
+    # In my opinion, we should use signal or extend save method only when we need to update this field in real time,
+    # but in this case of multiple rows imports, for better performance I used single update after import
+    # so it depends on business logic.
+    # Large imports should be done in batch, small individual updates, like in app by user, can be done with signals or extended save method.
+    balance = models.DecimalField(max_digits=12, decimal_places=2, default=0.00)
+
+    class Meta:
+        indexes = [
+            models.Index(fields=['name', 'currency']),
+        ]
      
     def __str__(self):
         return f'{self.name}[{self.currency}]'
@@ -31,6 +115,10 @@ class Statement(models.Model):
     account = models.ForeignKey(Account, on_delete=models.PROTECT)
     date = models.DateField()
     # TODO: TASK → make sure that account and date is unique on database level
+    class Meta:
+        constraints = [
+            models.UniqueConstraint(fields=['account', 'date'], name='unique_account_date_pair')
+        ]
 
     def __str__(self):
         return f'{self.account} → {self.date}'
@@ -41,7 +129,14 @@ class StatementItem(models.Model):
     amount = models.DecimalField(max_digits=6, decimal_places=2)
     currency = models.CharField(max_length=3)
     title = models.CharField(max_length=100)
+    account = models.ForeignKey(Account, on_delete=models.CASCADE)
     # TODO:  TASK → add field comments (type text)
+    comments = models.TextField(blank=True)
+
+    class Meta:
+        indexes = [
+            models.Index(fields=['account', 'currency']),
+        ]
     
 
     def __str__(self):
diff --git a/statements/tools.py b/statements/tools.py
index 146f40a..9747f2c 100644
--- a/statements/tools.py
+++ b/statements/tools.py
@@ -1,29 +1,57 @@
 import csv
 
+from django.db import transaction
+from django.db.models import Sum
 from django.core.exceptions import ValidationError
 from statements.models import Account, Statement, StatementItem
 
 def statement_import(file_handler):
     idx = 0
     # TODO: TASK → in case of errors database must not change
+    # Added transaction.atomic() to ensure that if any error occurs during the import process, all changes made to the database are rolled back.
     # TODO: TASK → optimize database queries during import
-    for row in csv.DictReader(file_handler):
-        account = Account.objects.get_or_create(
-            name=row['account'],
-            defaults={'currency': row['currency']}
-        )[0]
-        if account.currency != row['currency']:
-            raise ValidationError('Invalid currency currency ')
+    #I would use here Redis, below dicts are only for simplicity purposes. Main goal is that we have to reduce db queries.
+    #Simple logic for caching, if account is not in cache, we create it and add to cache, same with statements
+    #We had a bug here, because titles for StatementItem were not adding to DB, I fixed it
+    #I added statementItem bulk_create to reduce the number of create queries to the database
+    with transaction.atomic():
+        accounts_cache = {}
+        statements_cache = {}
+        statement_items = []
+        for row in csv.DictReader(file_handler):
+            account_key = (row['account'], row['currency'])
+            if account_key not in accounts_cache:
+                account = Account.objects.get_or_create(
+                    name=row['account'],
+                    defaults={'currency': row['currency']}
+                )[0]
+                if account.currency != row['currency']:
+                    raise ValidationError('Invalid currency currency ')
+                accounts_cache[account_key] = account
+            else:
+                account = accounts_cache[account_key]
+            statement_key = (account.id, row['date'])
+            if statement_key not in statements_cache:
+                statement = Statement.objects.get_or_create(
+                    account=account,
+                    date=row['date']
+                )[0]
+                statements_cache[statement_key] = statement
+            else:
+                statement = statements_cache[statement_key]
+            statement_items.append(StatementItem(
+                statement=statement,
+                amount=row['amount'],
+                currency=row['currency'],
+                title=row['title'],
+                account=account
+            ))
+            idx += 1
+        StatementItem.objects.bulk_create(statement_items)
+
+        account_balances = StatementItem.objects.values('account').annotate(balance_sum=Sum('amount'))
+        for balance_data in account_balances:
+            Account.objects.filter(id=balance_data['account']).update(balance=balance_data['balance_sum'])
 
-        statement = Statement.objects.get_or_create(
-            account=account,
-            date=row['date']
-        )[0]
-        StatementItem.objects.create(
-            statement=statement,
-            amount=row['amount'],
-            currency=row['currency'],
-        )
-        idx += 1
     return idx
 
